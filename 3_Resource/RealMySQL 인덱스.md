---
title: RealMySQL 인덱스
aliases:
  - RealMySQL 8장
classification: resource
tags:
  - RealMySQL
  - index
url:
created: 2025-12-23T11:08
updated: 2026-01-01T16:30
---

## B-Tree(Balanced-Tree)

- 일반적으로 가장 많이 사용되는 인덱스 알고리즘
- 컬럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱
- Root node - Branch node - Leaf node로 구성
- DBMS에서 B-Tree는 자식 노드의 개수가 가변적인 구조다.

인덱스 키 추가
- B-Tree에 저장될 때는 키 값을 이용해 적절한 위치를 검색한 후 Leaf node에 키와 주소 정보를 저장
	- Leaf node가 꽉 찬 경우 분리 작업이 상위 브랜치 노드까지 영향을 미치므로 쓰기 비용이 상대적으로 높다.
- 대략적인 비용은 레코드 추가 비용을 1로 볼 때, 인덱스 하나당 1.5 정도의 비용이 추가됨
	- 비용의 대부분은 디스크 I/O
- MyISAM이나 MEMORY 엔진은 즉시 인덱스에 반영하지만, InnoDB는 체인지 버퍼를 이용해 지연 처리 가능
	- 단, InnoDB에서도 중복 체크가 필요한 프라이머리 키나 유니크 인덱스는 즉시 처리함
인덱스 키 삭제
- 해당 키가 저장된 Leaf node를 찾아 삭제 마크만 수행하면 완료됨
- 삭제 마킹 작업도 디스크 I/O가 필요
- InnoDB 엔진은 이 작업을 버퍼링하여 지연 처리할 수 있다.
- MyISAM이나 MEMORY 엔진은 즉시 처리
인덱스 키 변경
- 키 값에 따라 저장될 위치가 달라지므로 단순 변경은 불가능하다.
- 기존 키 값을 삭제한 후 새로운 키 값을 추가하는 형태로 처리
- InnoDB 엔진은 이 삭제 및 추가 작업 모두 체인지 버퍼를 활용해 지연 처리 가능
인덱스 키 검색
- 인덱스 구축의 주 목적이며, 루트에서 Leaf node까지 이동하며 비교하는 트리 탐색 과정을 거친다.
- SELECT뿐만 아니라 UPDATE나 DELETE를 위해 레코드를 검색할 때도 사용된다.
- 100% 일치하거나 값의 앞부분(Left-most part)이 일치하는 경우에만 사용 가능
- 키 값의 뒷부분만 검색하거나 함수/연산 등으로 값이 변형된 경우 인덱스 사용 불가
- InnoDB는 인덱스를 잠근 후 레코드를 잠그는 방식(넥스트 키 락/갭 락)을 사용하므로, 적절한 인덱스가 없으면 불필요하게 많은 레코드(심하면 전체)가 잠길 수 있음

### B-Tree 인덱스를 통한 데이터 읽기

Index Range Scan
- 인덱스 접근 방법 중 가장 대표적이며 빠른 방식
- 루트 노드부터 리프 노드까지 탐색해 시작 위치를 찾은 뒤, 필요한 만큼 리프 노드를 순서대로 읽는다.
- 인덱스 자체는 정렬되어 있어 읽은 결과도 자동으로 정렬된다.
- 리프 노드에서 실제 데이터 파일의 레코드를 읽을 때마다 랜덤 I/O가 발생한다.
- 읽어야 할 데이터가 전체의 20~25퍼센트를 넘으면 인덱스보다 테이블을 직접 읽는 것이 더 효율적이다.
>[!info]
>일반적으로 DMBS의 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 정도 비용이 더 많이 드는 작업인 것으로 예측한다.
인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고 테이블을 모두 직접 읽어서 필요한 레코드만 필터링하는 방식으로 처리하는 것이 효율적이다.

- 쿼리에 필요한 모든 데이터가 인덱스에만 있다면 데이터 파일을 읽는 과정이 생략되는데, 이를 커버링 인덱스라고 합니다.

Index Full Scan
- 인덱스의 처음부터 끝까지 모든 리프 노드를 읽는 방식
- 쿼리 조건절에 인덱스의 첫 번째 칼럼이 사용되지 않았지만, 쿼리에 필요한 모든 칼럼이 인덱스에 포함된 경우에 주로 사용된다.
	- 데이터 레코드까지 모두 읽어야 하는 경우에는 이 방식이 사용되지 않는다.

Loose Index Scan
- 인덱스를 듬성듬성하게 읽으며 불필요한 키 값은 Skip하고 넘어가는 방식
	- 주로 GROUP BY 또는 집합 함수(MAX, MIN) 최적화에 사용된다.
- 조건에 만족하지 않는 레코드는 읽지 않고 다음 레코드로 이동하므로 전체를 스캔할 필요가 없다.

Index Skip Scan
- 인덱스가 다중 컬럼 인덱스일 경우, WHERE 절에 인덱스의 선행 칼럼에 대한 조건이 없어도 인덱스 검색을 가능하게 한다.
	- MySQL 8.0부터 도입된 최적화 기능
- 옵티마이저가 선행 칼럼의 유니크한 값을 추출해, 해당 값을 조건에 추가한 쿼리를 내부적으로 여러 번 실행하는 방식으로 처리한다.
- 선행 칼럼의 유니크한 값의 개수가 적어야 하며, 커버링 인덱스일 때만 적용된다.
	- 커버링 인덱스 : 쿼리가 인덱스 칼럼만으로 처리 가능한 경우

### 다중 컬럼 인덱스

- 두개 이상의 컬럼으로 구성된 인덱스
- 인덱스의 컬럼 순서에 따라 컬럼 별 앞 컬럼에 의존해서 정렬된다.
- 인덱스의 컬럼 순서가 매우 중요하며, 신중히 결정해야 한다.

### B-Tree 인덱스의 정렬 및 스캔 방향

InnoDB에서 인덱스 역순 스캔이 정순 스캔에 비해 느린 이유
- 페이지 잠금이 인덱스 정순 스캔에 적합한 구조
- 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조

## R-Tree

- MBR 사각형들의 포함 관계를 B-Tree 형태로 구현한 공간 인덱스
>[!info]
>MBR(Minimum Bounding Rectangle)
>- 도형을 감싸는 최소 크기의 사각형

## Full Text Index(전문 검색 인덱스)

### 인덱스 알고리즘

어근 분석 알고리즘
- 불용어 처리, 어근 분석

n-gram 알고리즘
- 본문을 일정한 글자로 잘라서 인덱싱하는 방법

불용어 처리를 무시하는 방법
- 스토리지 엔진에 관계없이 MySQL 서버의 모든 전문 검색 인덱스에 대해 불용어를 완전히 제거
- InnoDB 스토리지 엔진을 사용하는 테이블의 전문 검색 인덱스에 대해서만 불용어 처리 무시

Full Text Index의 가용성
- 쿼리 문장이 전문 검색을 위한 문법을 사용해야 한다.
- 테이블이 전문 검색 대상 컬럼에 대해서 전문 인덱스를 보유해야 한다.

## 함수 기반 인덱스

- 컬럼의 값을 변형한 값에 대해 인덱스를 구축하는 것

가상 컬럼을 이용한 인덱스
- 가상 컬럼은 테이블에 새로운 컬럼을 추가하는 것과 같은 효과를 내기 때문에 실제 테이블의 구조가 변경된다

```sql
ALTER TABLE user  
    ADD full_name VARCHAR(30) AS (CONCAT(first_name, ' ', last_name)) VIRTUAL,  
    ADD INDEX ix_fullname (full_name);
```

함수를 이용한 인덱스
- 테이블 구조를 변경하지 않고, 함수를 직접 사용하d는 인덱스

```sql
CREATE TABLE user  
(  
    user_id    BIGINT,  
    first_name VARCHAR(10),  
    last_name  VARCHAR(10),  
    PRIMARY KEY (user_id),  
    INDEX ix_fullname ((CONCAT(first_name, ' ', last_name)))  
);
```

## 멀티 밸류 인덱스

- 하나의 데이터 레코드가 여러 개의 키 값을 가질 수 있는 형태의 인덱스
- 멀티 밸류 인덱스를 활용하기 위해서는 반드시 다음 함수들을 이용해 검색해야 옵티마이저가 인덱스를 활용한 실행 계획을 수립한다.
	- `MEMBER OF()`
	- `JSON_CONTAINS()`
	- `JSON_OVERLAPS()`

## 클러스터링 인덱스

- 테이블의 PK에 대해서만 적용되는 내용으로, PK 값이 비슷한 레코들끼리 묶어서 저장하는 것을 클러스터링 인덱스라고 한다.
	- PK 값에 의해 레코드의 저장 위치가 결정된다.
	- PK가 변경되면 물리적인 저장 위치가 변경된다.
- 일반적으로 InnoDB와 같이 항상 클러스터링 인덱스로 저장되는 테이블은 프라이머리 키 기반의 검색이 매우 빠르며, 대신 레코드의 저장이나 프라이머리 키의 변경이 상대적으로 느리다.
- PK가 없는 테이블의 경우 다음과 같은 우선순위대로 PK를 대체할 컬럼을 선택한다.
	1. 프라이머리 키가 있으면 기본적으로 프라이머리 키를 클러스터링 키로 선택
	2. NOT NULL 옵션의 유니크 인덱스(UNIQUE INDEX) 중에서 첫 번째 인덱스를 클러스터링 키로 선택
	3. 자동으로 유니크한 값을 가지도록 증가되는 칼럼을 내부적으로 추가한 후, 클러스터링 키로 선택
- 클러스터링 테이블의 모든 세컨더리 인덱스는 해당 레코드의 저장된 주소가 아니라 PK 값을 저장하도록 구현돼 있다.
	- MyISAM : 인덱스를 검색해서 레코드의 주소를 확인 후, 레코드의 주소를 이용해 최종 레코드 가져옴
	- InnoDB : 인덱스를 검색해서 PK 값을 확인 후 PK 인덱스를 검색해서 최종 레코드 가져옴

pros
- PK 검색 시 처리 성능이 매우 빠름
- 테이블의 모든 세컨더리 인덱스가 PK를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많다.
	- 커버링 인덱스

cons
- 테이블의 모든 세컨더리 인덱스가 PK를 가지고 있기 때문에 클러스터링 키 값이 크기가 클 경우 전체 인덱스의 크기가 커진다.
- 세컨더리 인덱스를 통해 검색할 때 PK로 다시 검색해서 처리 성능이 느리다.
- INSERT 시 PK에로 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느리다.
- 프라이머리 키를 변경할 때 레코드를 DELETE하고 INSERT하므로 처리 성능이 느리다.

### 클러스터링 테이블 사용 시 주의사항

- 클러스터링 인덱스 키의 크기
	- 모든 세컨더리 인덱스가 PK를 포함하기 떄문에 PK 크기가 커지면 세컨더리 인덱스도 자동으로 커진다.
	- PK를 신중하게 선택헤야 한다.
- PK는 AUTO_INCREMENT보다 업무적인 컬럼으로 생성
	- PK가 매우 중요한 역할을 하기 때문에 대부분의 검색에서 빈번하게 사용되는 것이 일반적
	- 컬럼의 크기가 크더라도 업무적으로 레코드를 대표할 수 있다면 유의미한 PK를 설정하는 것이 좋다.
- PK는 반드시 명시적으로 설정
- PK가 길어질 경우 세컨더리 인덱스가 필요하지 않다면 사용해도 좋지만 필요하다면 인조 식별자(AUTO_INCREMENT)를 추가하는 것이 좋다.

## 유니크 인덱스

- 일반 세컨더리 인덱스와 구조상 아무런 차이점이 없다.
	- 제약조건의 차이

### 유니크 인덱스 읽기

- 유니크 인덱스가 빠른 것처럼 보이지만 중복을 허용하지 않아 읽은 레코드의 수가 적을 뿐 성능이 크게 차이나진 않는다.

### 유니크 인덱스 쓰기

- 유니크 인덱스의 키 값을 쓸 때는 중복된 값이 있는 지 확인하기 때문에 유니크 하지 않은 인덱스보다 느리다.
- 중복을 체크할 때는 읽기 잠금, 쓸 때는 쓰기 잠금을 사용하는 과정에서 데드락이 빈번히 발생한다.

### 유니크 인덱스 주의사항

- 성능 개선을 위해 불필요하게 유니크 인덱스를 생성하지 않는 것이 좋다.
- 같이 컬럼의 세컨더리 인덱스나 PK와 동일하게 유니크 인덱스를 생성하는 경우 인덱스 관점에서는 불필요한 중복이다.

## 외래키

- InnoDB 스토리지 엔진에서만 생성할 수 있으며, 외래키 제약이 설정되면 자동으로 연관되는 테이블의 컬럼에 인덱스도 생성된다.
- 테이블의 변경(쓰기 잠금)이 발생하는 경우에만 잠금 경합(잠금 대기)이 발생한다.
- 외래키와 연관되지 않은 칼럼의 변경은 최대한 잠금 경합(잠금 대기)을 발생시키지 않는다.
- 부모 테이블의 데이터 삭제 시 자식 테이블의 FK 레코드도 함께 삭제된다.
