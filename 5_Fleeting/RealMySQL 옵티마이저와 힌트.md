---
title: RealMySQL 옵티마이저와 힌트
aliases:
  - RealMySQL 8.0 9장
classification:
tags:
  - MySQL
  - RealMySQL
  - db
url:
created: 2026-01-01T16:29
updated: 2026-01-01T21:43
---

## 개요

### 쿼리 실행 절차

1. SQL 문장을 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리한다.
	- SQL 파스 트리가 만들어진다.
2. SQL의 파싱 정보를 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다.
	- 불필요한 조건 제거 및 복잡한 연산 단순화
	- 여러 테이블의 조인이 있는 경우 순서 결정
	- 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스 결정
	- 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정
3. 결정된 테이블 순서나 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다.

### 옵티마이저의 종류

비용 기반 최적화(Cost-based optimizer, CBO)
- 쿼리를 처리하기 위한 여러가지 방법을 만들고, 각작업의 비용과 예측된 통계 정보를 이용해 실행 계획 별 비용을 산출하고, 최소로 소요되는 처리 방식을 선택한다.
규칙 기반 최적화(Rule-based optimizer, RBO)
- 테이블의 레코드 수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립하는 방식

## 기본 데이터 처리

### 풀 테이블 스캔과 풀 인덱스 스캔

풀 테이블 스캔을 하는 경우
- 테이블의 레코드 건수가 너무 작아서 인덱스를 통해 읽는 것보다 풀 테이블 스캔을 하는 편이 더 빠른 경우
- WHERE절이나 ON절에 인덱스를 이용할 수 있는 적절한 조건이 없는 경우
- 인덱스 레인지 스캔을 사용할 수 있는 쿼리지만, 옵티마이저가 판단한 조건 일치 레코드 건수가 너무 많은 경우

Read ahead
- 데이터가 앞으로 필요해지리라는 것을 예측해서 요청이 오기 전에 미리 디스크에서 읽어 InnoDB 버퍼 풀에 가져다 두는 것
- InnoDB 스토리지 엔진은 특정 테이블의 연속된 데이터 페이지가 읽히면 백그라운드 스레드에 의해 Read ahead 작업이 이루어진다.
- 데이터 웨어하우스용으로 MySQL을 사용한다면 `innodb_read_ahead_threshold` 값을 낮은 값으로 설정해서 더 빨리 Read ahead가 시작되게 유도하는 것도 좋은 방법이다.

### 병렬 처리
- `innodb_parallel_read_threads` 시스템 변수를 이용해 하나의 쿼리를 최대 몇 개의 스레드를 이용해서 처리할지를 변경할 수 있다.
- 병렬 처리용 스레드 개수가 CPU 코어 개수를 넘어서는 경우에는 오히려 성능이 떨어질 수 있다.

### ORDER BY
![](https://i.imgur.com/4vCNbDf.png)

다음과 같은 이유로 모든 정렬을 인덱스를 이용하도록 튜닝하기란 불가능하므로 Filesort 정렬을 사용한다.
- 정렬 기준이 많아서 요건 별로 모두 인덱스를 생성하는 것이 불가능한 경우
- GROUP BY의 결과 또는 DISTINCT 같은 처리의 결과를 정렬해야 하는 경우
- UNION의 결과와 같이 임시 테이블의 결과를 다시 정렬해야 하는 경우
- 랜덤하게 결과 레코드를 가져와야 하는 경우


Sort buffer
- 정렬을 수행하기 위한 별도의 메모리 공간
- 정렬해야 할 레코드의 건수가 Sort buffer 공간 보다 크다면 레코드를 여러 조각으로 나누고 임시 저장을 위해 디스크를 사용한다.
	- 정렬 결과를 디스크에 임시 기록하고 병합한다. (Multi-merge)
- Sort buffer 크기를 크게 설정한다고 성능상의 큰 차이는 없고 오히려 메모리가 부족할 수 있다.
	- 디스크의 읽기와 쓰기 사용량은 줄일 수 있다.

