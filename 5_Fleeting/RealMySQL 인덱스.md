---
title: RealMySQL 인덱스
aliases:
  - RealMySQL 8장
classification: resource
tags:
  - RealMySQL
  - index
url:
created: 2025-12-23T11:08
updated: 2025-12-23T17:16
---

## B-Tree(Balanced-Tree)

- 일반적으로 가장 많이 사용되는 인덱스 알고리즘
- 컬럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱
- Root node - Branch node - Leaf node로 구성
- DBMS에서 B-Tree는 자식 노드의 개수가 가변적인 구조다.

인덱스 키 추가
- B-Tree에 저장될 때는 키 값을 이용해 적절한 위치를 검색한 후 Leaf node에 키와 주소 정보를 저장
	- Leaf node가 꽉 찬 경우 분리 작업이 상위 브랜치 노드까지 영향을 미치므로 쓰기 비용이 상대적으로 높다.
- 대략적인 비용은 레코드 추가 비용을 1로 볼 때, 인덱스 하나당 1.5 정도의 비용이 추가됨
	- 비용의 대부분은 디스크 I/O
- MyISAM이나 MEMORY 엔진은 즉시 인덱스에 반영하지만, InnoDB는 체인지 버퍼를 이용해 지연 처리 가능
	- 단, InnoDB에서도 중복 체크가 필요한 프라이머리 키나 유니크 인덱스는 즉시 처리함
인덱스 키 삭제
- 해당 키가 저장된 Leaf node를 찾아 삭제 마크만 수행하면 완료됨
- 삭제 마킹 작업도 디스크 I/O가 필요
- InnoDB 엔진은 이 작업을 버퍼링하여 지연 처리할 수 있다.
- MyISAM이나 MEMORY 엔진은 즉시 처리
인덱스 키 변경
- 키 값에 따라 저장될 위치가 달라지므로 단순 변경은 불가능하다.
- 기존 키 값을 삭제한 후 새로운 키 값을 추가하는 형태로 처리
- InnoDB 엔진은 이 삭제 및 추가 작업 모두 체인지 버퍼를 활용해 지연 처리 가능
인덱스 키 검색
- 인덱스 구축의 주 목적이며, 루트에서 Leaf node까지 이동하며 비교하는 트리 탐색 과정을 거친다.
- SELECT뿐만 아니라 UPDATE나 DELETE를 위해 레코드를 검색할 때도 사용된다.
- 100% 일치하거나 값의 앞부분(Left-most part)이 일치하는 경우에만 사용 가능
- 키 값의 뒷부분만 검색하거나 함수/연산 등으로 값이 변형된 경우 인덱스 사용 불가
- InnoDB는 인덱스를 잠근 후 레코드를 잠그는 방식(넥스트 키 락/갭 락)을 사용하므로, 적절한 인덱스가 없으면 불필요하게 많은 레코드(심하면 전체)가 잠길 수 있음

### B-Tree 인덱스를 통한 데이터 읽기

Index Range Scan
- 인덱스 접근 방법 중 가장 대표적이며 빠른 방식
- 루트 노드부터 리프 노드까지 탐색해 시작 위치를 찾은 뒤, 필요한 만큼 리프 노드를 순서대로 읽는다.
- 인덱스 자체는 정렬되어 있어 읽은 결과도 자동으로 정렬된다.
- 리프 노드에서 실제 데이터 파일의 레코드를 읽을 때마다 랜덤 I/O가 발생한다.
- 읽어야 할 데이터가 전체의 20~25퍼센트를 넘으면 인덱스보다 테이블을 직접 읽는 것이 더 효율적이다.
>[!info]
>일반적으로 DMBS의 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 정도 비용이 더 많이 드는 작업인 것으로 예측한다.
인덱스를 통해 읽어야 할 레코드의 건수가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고 테이블을 모두 직접 읽어서 필요한 레코드만 필터링하는 방식으로 처리하는 것이 효율적이다.

- 쿼리에 필요한 모든 데이터가 인덱스에만 있다면 데이터 파일을 읽는 과정이 생략되는데, 이를 커버링 인덱스라고 합니다.

Index Full Scan
- 인덱스의 처음부터 끝까지 모든 리프 노드를 읽는 방식
- 쿼리 조건절에 인덱스의 첫 번째 칼럼이 사용되지 않았지만, 쿼리에 필요한 모든 칼럼이 인덱스에 포함된 경우에 주로 사용된다.
	- 데이터 레코드까지 모두 읽어야 하는 경우에는 이 방식이 사용되지 않는다.

Loose Index Scan
- 인덱스를 듬성듬성하게 읽으며 불필요한 키 값은 Skip하고 넘어가는 방식
	- 주로 GROUP BY 또는 집합 함수(MAX, MIN) 최적화에 사용된다.
- 조건에 만족하지 않는 레코드는 읽지 않고 다음 레코드로 이동하므로 전체를 스캔할 필요가 없다.

Index Skip Scan
- 인덱스가 다중 컬럼 인덱스일 경우, WHERE 절에 인덱스의 선행 칼럼에 대한 조건이 없어도 인덱스 검색을 가능하게 한다.
	- MySQL 8.0부터 도입된 최적화 기능
- 옵티마이저가 선행 칼럼의 유니크한 값을 추출해, 해당 값을 조건에 추가한 쿼리를 내부적으로 여러 번 실행하는 방식으로 처리한다.
- 선행 칼럼의 유니크한 값의 개수가 적어야 하며, 커버링 인덱스일 때만 적용된다.
	- 커버링 인덱스 : 쿼리가 인덱스 칼럼만으로 처리 가능한 경우

### 다중 컬럼 인덱스

- 두개 이상의 컬럼으로 구성된 인덱스
- 인덱스의 컬럼 순서에 따라 컬럼 별 앞 컬럼에 의존해서 정렬된다.
- 인덱스의 컬럼 순서가 매우 중요하며, 신중히 결정해야 한다.

### B-Tree 인덱스의 정렬 및 스캔 방향

InnoDB에서 인덱스 역순 스캔이 정순 스캔에 비해 느린 이유
- 페이지 잠금이 인덱스 정순 스캔에 적합한 구조
- 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조

## R-Tree

- MBR 사각형들의 포함 관계를 B-Tree 형태로 구현한 공간 인덱스
>[!info]
>MBR(Minimum Bounding Rectangle)
>- 도형을 감싸는 최소 크기의 사각형

## Full Text Index(전문 검색 인덱스)

### 인덱스 알고리즘

어근 분석 알고리즘
- 불용어 처리, 어근 분석

n-gram 알고리즘
- 본문을 일정한 글자로 잘라서 인덱싱하는 방법

불용어 처리를 무시하는 방법
- 스토리지 엔진에 관계없이 MySQL 서버의 모든 전문 검색 인덱스에 대해 불용어를 완전히 제거
- InnoDB 스토리지 엔진을 사용하는 테이블의 전문 검색 인덱스에 대해서만 불용어 처리 무시

Full Text Index의 가용성
- 쿼리 문장이 전문 검색을 위한 문법을 사용해야 한다.
- 테이블이 전문 검색 대상 컬럼에 대해서 전문 인덱스를 보유해야 한다.
